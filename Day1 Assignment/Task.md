# Assignment1
### Where are your structs, mappings and arrays stored.
- **Structs:** They are stored in storage when they are declared as state variables or if they declared inside an array or mapping. Members(key:value pairs) are laid out sequentially in storage slots in the order they are declared. When there are multiple small variables inside the struct less than 32bytes, they are packed into a 32bytes storage slot whenever it's possible. When they are declared inside a function, they are stored temporarily in the EVM's trasient storage (memory/calldata).
- **Mappings:** Mappings are always stored in storage. They act like hash tables and each value is stored in a computed location.
- **Arrays:** Arrays are stored in storage if declared as state variables, but can be stored temporarily in memory or calldata when used in functions. For fixed-size arrays declared as state variables, they are stored side by side in storage and sometimes if their elements are tiny, can be packed into a 32 bytes storage slot.

<br>

### How they behave when executed or called.
- **Structs:** The behaviour of structs follows the rules of their members and their location. For structs declared in storage, reading means reading from storage and writing a struct member means writing to storage (very expensive). Assigning a state struct to another in state, copies the members of the initial struct and does not reference it. Declaring a struct inside a function and marking it as storage references to a struct declared in state, and modifying its members affects the storage reference struct. Structs in a function can be marked as memory and their storage in memory is wiped out after the function ends. For structs declared inside memory, they can have arrays and other data types as members but not mappings. Struct declared in call-data are read only inputs.
- **Mappings:** Mappings are read using `myMapping[key]` syntax and the result of that syntax is stored in a location determined by: keccak256(key+slot). Writing to mapping writes persistent storage hence, expensive. It is forbiddent to assign a Mapping A to Mapping B unlike arrays and structs. Using `delete myMapping[key]` only clears the slot to it's default value and doesn't reset the mapping. 
- **Array:** They behave differently depending on the location. When declared in storage, they can be read or written(expensive) and when assigned to another array in state environment, they get copied to that array and a separate slot is given to that array. When declared as storage in a function, they act as reference to another array in state environment. When declared as memory in a function, they act as a copy of the state array and do not reference to it. Memory arrays can be modified and only exist during the duration of the function execution. Arrays declared as calldata function inputs are read only and cost very cheap gas.

<br>

### Why don't you need to specify memory or storage with mappings
- Mappings in solidity is a special key-value feature that can only be declared in state environment. You don't need to specify storage with mappings, because as a solidity rule and with any state variable declaration implicitely saves them in storage. Only when you declare a variable in a function body or function argument you need to specify either memory, calldata, or storage reference. But in the case of mapping, it has no order, hence there is no way for solidity to loop through a mapping and this is why you can't declare mappings inside a function. And since they can't be in a function there is no business with setting their storage location as memory.